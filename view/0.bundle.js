(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "./view/assets/games/Go/wgo.js":
/*!*************************************!*\
  !*** ./view/assets/games/Go/wgo.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n * Copyright (c) 2013 Jan Prokop\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/* WGo.js 2.3.1 */\n(function (window, undefined) {\n  \"use strict\";\n\n  var scripts = document.getElementsByTagName('script');\n  var path = scripts[scripts.length - 1].src.split('?')[0]; // remove any ?query\n\n  var mydir = path.split('/').slice(0, -1).join('/') + '/';\n  /**\n   * Main namespace - it initializes WGo in first run and then execute main function.\n   * You must call WGo.init() if you want to use library, without calling WGo.\n   */\n\n  var WGo = {\n    // basic information\n    version: \"2.3.1\",\n    // constants for colors (rather use WGo.B or WGo.W)\n    B: 1,\n    W: -1,\n    // if true errors will be shown in dialog window, otherwise they will be ignored\n    ERROR_REPORT: true,\n    DIR: mydir,\n    // Language of player, you can change this global variable any time. Object WGo.i18n.<your lang> must exist.\n    lang: \"en\",\n    // Add terms for each language here\n    i18n: {\n      en: {}\n    }\n  }; // browser detection - can be handy\n\n  WGo.opera = navigator.userAgent.search(/(opera)(?:.*version)?[ \\/]([\\w.]+)/i) != -1;\n  WGo.webkit = navigator.userAgent.search(/(webkit)[ \\/]([\\w.]+)/i) != -1;\n  WGo.msie = navigator.userAgent.search(/(msie) ([\\w.]+)/i) != -1;\n  WGo.mozilla = navigator.userAgent.search(/(mozilla)(?:.*? rv:([\\w.]+))?/i) != -1 && !WGo.webkit && !WGo.msie; // translating function\n\n  WGo.t = function (str) {\n    var loc = WGo.i18n[WGo.lang][str] || WGo.i18n.en[str];\n\n    if (loc) {\n      for (var i = 1; i < arguments.length; i++) {\n        loc = loc.replace(\"$\", arguments[i]);\n      }\n\n      return loc;\n    }\n\n    return str;\n  }; // helping function for class inheritance\n\n\n  WGo.extendClass = function (parent, child) {\n    child.prototype = Object.create(parent.prototype);\n    child.prototype.constructor = child;\n    child.prototype[\"super\"] = parent;\n    return child;\n  }; // helping function for class inheritance\n\n\n  WGo.abstractMethod = function () {\n    throw Error('unimplemented abstract method');\n  }; // helping function for deep cloning of simple objects,\n\n\n  WGo.clone = function (obj) {\n    if (obj && _typeof(obj) == \"object\") {\n      var n_obj = obj.constructor == Array ? [] : {};\n\n      for (var key in obj) {\n        if (obj[key] == obj) n_obj[key] = obj;else n_obj[key] = WGo.clone(obj[key]);\n      }\n\n      return n_obj;\n    } else return obj;\n  }; // filter html to avoid XSS\n\n\n  WGo.filterHTML = function (text) {\n    if (!text || typeof text != \"string\") return text;\n    return text.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n  }; //---------------------- WGo.Board -----------------------------------------------------------------------------\n\n  /**\n   * Board class constructor - it creates a canvas board\n   *\n   * @param elem DOM element to put in\n   * @param config configuration object. It is object with \"key: value\" structure. Possible configurations are:\n   *\n   * - size: number - size of the board (default: 19)\n   * - width: number - width of the board (default: 0)\n   * - height: number - height of the board (default: 0)\n   * - font: string - font of board writings (!deprecated)\n   * - lineWidth: number - line width of board drawings (!deprecated)\n   * - autoLineWidth: boolean - if set true, line width will be automatically computed accordingly to board size - this option rewrites 'lineWidth' /and it will keep markups sharp/ (!deprecated)\n   * - starPoints: Object - star points coordinates, defined for various board sizes. Look at Board.default for more info.\n   * - stoneHandler: Board.DrawHandler - stone drawing handler (default: Board.drawHandlers.SHELL)\n   * - starSize: number - size of star points (default: 1). Radius of stars is dynamic, however you can modify it by given constant. (!deprecated)\n   * - stoneSize: number - size of stone (default: 1). Radius of stone is dynamic, however you can modify it by given constant. (!deprecated)\n   * - shadowSize: number - size of stone shadow (default: 1). Radius of shadow is dynamic, however you can modify it by given constant. (!deprecated)\n   * - background: string - background of the board, it can be either color (#RRGGBB) or url. Empty string means no background. (default: WGo.DIR+\"wood1.jpg\")\n   * - section: {\n   *     top: number,\n   *     right: number,\n   *     bottom: number,\n   *     left: number\n   *   }\n   *   It defines a section of board to be displayed. You can set a number of rows(or cols) to be skipped on each side.\n   *   Numbers can be negative, in that case there will be more empty space. In default all values are zeros.\n   * - theme: Object - theme object, which defines all graphical attributes of the board. Default theme object is \"WGo.Board.themes.default\". For old look you may use \"WGo.Board.themes.old\".\n   *\n   * Note: properties lineWidth, autoLineWidth, starPoints, starSize, stoneSize and shadowSize will be considered only if you set property 'theme' to 'WGo.Board.themes.old'.\n   */\n\n\n  var Board = function Board(elem, config) {\n    var config = config || {}; // set user configuration\n\n    for (var key in config) {\n      this[key] = config[key];\n    } // add default configuration\n\n\n    for (var key in WGo.Board[\"default\"]) {\n      if (this[key] === undefined) this[key] = WGo.Board[\"default\"][key];\n    } // add default theme variables\n\n\n    for (var key in Board.themes[\"default\"]) {\n      if (this.theme[key] === undefined) this.theme[key] = Board.themes[\"default\"][key];\n    } // set section if set\n\n\n    this.tx = this.section.left;\n    this.ty = this.section.top;\n    this.bx = this.size - 1 - this.section.right;\n    this.by = this.size - 1 - this.section.bottom; // init board\n\n    this.init(); // append to element\n\n    elem.appendChild(this.element); // set initial dimensions\n    // set the pixel ratio for HDPI (e.g. Retina) screens\n\n    this.pixelRatio = window.devicePixelRatio || 1;\n    if (this.width && this.height) this.setDimensions(this.width, this.height);else if (this.width) this.setWidth(this.width);else if (this.height) this.setHeight(this.height);\n  }; // New experimental board theme system - it can be changed in future, if it will appear to be unsuitable.\n\n\n  Board.themes = {};\n  Board.themes.old = {\n    shadowColor: \"rgba(32,32,32,0.5)\",\n    shadowTransparentColor: \"rgba(32,32,32,0)\",\n    shadowBlur: 0,\n    shadowSize: function shadowSize(board) {\n      return board.shadowSize;\n    },\n    markupBlackColor: \"rgba(255,255,255,0.8)\",\n    markupWhiteColor: \"rgba(0,0,0,0.8)\",\n    markupNoneColor: \"rgba(0,0,0,0.8)\",\n    markupLinesWidth: function markupLinesWidth(board) {\n      return board.autoLineWidth ? board.stoneRadius / 7 : board.lineWidth;\n    },\n    gridLinesWidth: 1,\n    gridLinesColor: function gridLinesColor(board) {\n      return \"rgba(0,0,0,\" + Math.min(1, board.stoneRadius / 15) + \")\";\n    },\n    starColor: \"#000\",\n    starSize: function starSize(board) {\n      return board.starSize * (board.width / 300 + 1);\n    },\n    stoneSize: function stoneSize(board) {\n      return board.stoneSize * Math.min(board.fieldWidth, board.fieldHeight) / 2;\n    },\n    coordinatesColor: \"rgba(0,0,0,0.7)\",\n    font: function font(board) {\n      return board.font;\n    },\n    linesShift: 0.5\n  };\n  /**\n   * Object containing default graphical properties of a board.\n   * A value of all properties can be even static value or function, returning final value.\n   * Theme object doesn't set board and stone textures - they are set separately.\n   */\n\n  Board.themes[\"default\"] = {\n    shadowColor: \"rgba(62,32,32,0.5)\",\n    shadowTransparentColor: \"rgba(62,32,32,0)\",\n    shadowBlur: function shadowBlur(board) {\n      return board.stoneRadius * 0.1;\n    },\n    shadowSize: 1,\n    markupBlackColor: \"rgba(255,255,255,0.9)\",\n    markupWhiteColor: \"rgba(0,0,0,0.7)\",\n    markupNoneColor: \"rgba(0,0,0,0.7)\",\n    markupLinesWidth: function markupLinesWidth(board) {\n      return board.stoneRadius / 8;\n    },\n    gridLinesWidth: function gridLinesWidth(board) {\n      return board.stoneRadius / 15;\n    },\n    gridLinesColor: \"#654525\",\n    starColor: \"#531\",\n    starSize: function starSize(board) {\n      return board.stoneRadius / 8 + 1;\n    },\n    stoneSize: function stoneSize(board) {\n      return Math.min(board.fieldWidth, board.fieldHeight) / 2;\n    },\n    coordinatesColor: \"#531\",\n    variationColor: \"rgba(0,32,128,0.8)\",\n    font: \"calibri\",\n    linesShift: 0.25\n  };\n\n  var theme_variable = function theme_variable(key, board) {\n    return typeof board.theme[key] == \"function\" ? board.theme[key](board) : board.theme[key];\n  };\n\n  var shadow_handler = {\n    draw: function draw(args, board) {\n      var xr = board.getX(args.x),\n          yr = board.getY(args.y),\n          sr = board.stoneRadius;\n      this.beginPath();\n      var blur = theme_variable(\"shadowBlur\", board);\n      var radius = Math.max(0, sr - 0.5);\n      var gradient = this.createRadialGradient(xr - board.ls, yr - board.ls, radius - 1 - blur, xr - board.ls, yr - board.ls, radius + blur);\n      gradient.addColorStop(0, theme_variable(\"shadowColor\", board));\n      gradient.addColorStop(1, theme_variable(\"shadowTransparentColor\", board));\n      this.fillStyle = gradient;\n      this.arc(xr - board.ls, yr - board.ls, radius + blur, 0, 2 * Math.PI, true);\n      this.fill();\n    },\n    clear: function clear(args, board) {\n      var xr = board.getX(args.x),\n          yr = board.getY(args.y),\n          sr = board.stoneRadius;\n      this.clearRect(xr - 1.1 * sr - board.ls, yr - 1.1 * sr - board.ls, 2.2 * sr, 2.2 * sr);\n    }\n  }; // Shadow handler for the 'REALISITC' rendering mode\n\n  var shadow_handler_realistic = {\n    draw: function draw(args, board) {\n      var xr = board.getX(args.x),\n          yr = board.getY(args.y),\n          sr = board.stoneRadius,\n          lsX = 1.0,\n          lsY = -5.0,\n          blur = 5.0;\n      this.beginPath();\n      var radius = Math.max(0, (sr - 0.5) * 0.85);\n      var gradient = this.createRadialGradient(xr - lsX, yr - lsY, radius - 1 - blur, xr - lsX, yr - lsY, radius + blur);\n      gradient.addColorStop(0, theme_variable(\"shadowColor\", board));\n      gradient.addColorStop(1, theme_variable(\"shadowTransparentColor\", board));\n      this.fillStyle = gradient;\n      this.arc(xr - lsX, yr - lsY, radius + blur, 0, 2 * Math.PI, true);\n      this.fill();\n    },\n    clear: function clear(args, board) {\n      var xr = board.getX(args.x),\n          yr = board.getY(args.y),\n          sr = board.stoneRadius,\n          lsX = 1.0,\n          lsY = -5.0,\n          blur = 5.0;\n      this.clearRect(xr - 1.1 * sr - lsX, yr - 1.1 * sr - lsY, 2.2 * sr, 2.2 * sr);\n    }\n  };\n\n  var get_markup_color = function get_markup_color(board, x, y) {\n    if (board.obj_arr[x][y][0].c == WGo.B) return theme_variable(\"markupBlackColor\", board);else if (board.obj_arr[x][y][0].c == WGo.W) return theme_variable(\"markupWhiteColor\", board);\n    return theme_variable(\"markupNoneColor\", board);\n  };\n\n  var is_here_stone = function is_here_stone(board, x, y) {\n    return board.obj_arr[x][y][0] && board.obj_arr[x][y][0].c == WGo.W || board.obj_arr[x][y][0].c == WGo.B;\n  };\n\n  var redraw_layer = function redraw_layer(board, layer) {\n    var handler;\n    board[layer].clear();\n    board[layer].draw(board);\n\n    for (var x = 0; x < board.size; x++) {\n      for (var y = 0; y < board.size; y++) {\n        for (var z = 0; z < board.obj_arr[x][y].length; z++) {\n          var obj = board.obj_arr[x][y][z];\n          if (!obj.type) handler = board.stoneHandler;else if (typeof obj.type == \"string\") handler = Board.drawHandlers[obj.type];else handler = obj.type;\n          if (handler[layer]) handler[layer].draw.call(board[layer].getContext(obj), obj, board);\n        }\n      }\n    }\n\n    for (var i = 0; i < board.obj_list.length; i++) {\n      var obj = board.obj_list[i];\n      var handler = obj.handler;\n      if (handler[layer]) handler[layer].draw.call(board[layer].getContext(obj.args), obj.args, board);\n    }\n  }; // shell stone helping functions\n\n\n  var shell_seed;\n\n  var draw_shell_line = function draw_shell_line(ctx, x, y, radius, start_angle, end_angle, factor, thickness) {\n    ctx.strokeStyle = \"rgba(64,64,64,0.2)\";\n    ctx.lineWidth = radius / 30 * thickness;\n    ctx.beginPath();\n    radius -= Math.max(1, ctx.lineWidth);\n    var x1 = x + radius * Math.cos(start_angle * Math.PI);\n    var y1 = y + radius * Math.sin(start_angle * Math.PI);\n    var x2 = x + radius * Math.cos(end_angle * Math.PI);\n    var y2 = y + radius * Math.sin(end_angle * Math.PI);\n    var m, angle, x, diff_x, diff_y;\n\n    if (x2 > x1) {\n      m = (y2 - y1) / (x2 - x1);\n      angle = Math.atan(m);\n    } else if (x2 == x1) {\n      angle = Math.PI / 2;\n    } else {\n      m = (y2 - y1) / (x2 - x1);\n      angle = Math.atan(m) - Math.PI;\n    }\n\n    var c = factor * radius;\n    diff_x = Math.sin(angle) * c;\n    diff_y = Math.cos(angle) * c;\n    var bx1 = x1 + diff_x;\n    var by1 = y1 - diff_y;\n    var bx2 = x2 + diff_x;\n    var by2 = y2 - diff_y;\n    ctx.moveTo(x1, y1);\n    ctx.bezierCurveTo(bx1, by1, bx2, by2, x2, y2);\n    ctx.stroke();\n  };\n\n  var draw_shell = function draw_shell(arg) {\n    var from_angle = arg.angle;\n    var to_angle = arg.angle;\n\n    for (var i = 0; i < arg.lines.length; i++) {\n      from_angle += arg.lines[i];\n      to_angle -= arg.lines[i];\n      draw_shell_line(arg.ctx, arg.x, arg.y, arg.radius, from_angle, to_angle, arg.factor, arg.thickness);\n    }\n  }; // drawing handlers\n\n\n  Board.drawHandlers = {\n    // handler for normal stones\n    NORMAL: {\n      // draw handler for stone layer\n      stone: {\n        // drawing function - args object contain info about drawing object, board is main board object\n        // this function is called from canvas2D context\n        draw: function draw(args, board) {\n          var xr = board.getX(args.x),\n              yr = board.getY(args.y),\n              sr = board.stoneRadius,\n              radgrad; // set stone texture\n\n          if (args.c == WGo.W) {\n            radgrad = this.createRadialGradient(xr - 2 * sr / 5, yr - 2 * sr / 5, sr / 3, xr - sr / 5, yr - sr / 5, 5 * sr / 5);\n            radgrad.addColorStop(0, '#fff');\n            radgrad.addColorStop(1, '#aaa');\n          } else {\n            radgrad = this.createRadialGradient(xr - 2 * sr / 5, yr - 2 * sr / 5, 1, xr - sr / 5, yr - sr / 5, 4 * sr / 5);\n            radgrad.addColorStop(0, '#666');\n            radgrad.addColorStop(1, '#000');\n          } // paint stone\n\n\n          this.beginPath();\n          this.fillStyle = radgrad;\n          this.arc(xr - board.ls, yr - board.ls, Math.max(0, sr - 0.5), 0, 2 * Math.PI, true);\n          this.fill();\n        }\n      },\n      // adding shadow handler\n      shadow: shadow_handler\n    },\n    PAINTED: {\n      stone: {\n        draw: function draw(args, board) {\n          var xr = board.getX(args.x),\n              yr = board.getY(args.y),\n              sr = board.stoneRadius,\n              radgrad;\n\n          if (args.c == WGo.W) {\n            radgrad = this.createRadialGradient(xr - 2 * sr / 5, yr - 2 * sr / 5, 2, xr - sr / 5, yr - sr / 5, 4 * sr / 5);\n            radgrad.addColorStop(0, '#fff');\n            radgrad.addColorStop(1, '#ddd');\n          } else {\n            radgrad = this.createRadialGradient(xr - 2 * sr / 5, yr - 2 * sr / 5, 1, xr - sr / 5, yr - sr / 5, 4 * sr / 5);\n            radgrad.addColorStop(0, '#111');\n            radgrad.addColorStop(1, '#000');\n          }\n\n          this.beginPath();\n          this.fillStyle = radgrad;\n          this.arc(xr - board.ls, yr - board.ls, Math.max(0, sr - 0.5), 0, 2 * Math.PI, true);\n          this.fill();\n          this.beginPath();\n          this.lineWidth = sr / 6;\n\n          if (args.c == WGo.W) {\n            this.strokeStyle = '#999';\n            this.arc(xr + sr / 8, yr + sr / 8, sr / 2, 0, Math.PI / 2, false);\n          } else {\n            this.strokeStyle = '#ccc';\n            this.arc(xr - sr / 8, yr - sr / 8, sr / 2, Math.PI, 1.5 * Math.PI);\n          }\n\n          this.stroke();\n        }\n      },\n      shadow: shadow_handler\n    },\n    // handler for image based stones\n    REALISTIC: {\n      stone: {\n        draw: function draw(args, board) {\n          var xr = board.getX(args.x),\n              yr = board.getY(args.y),\n              sr = board.stoneRadius;\n          var whiteCount = board.whiteStoneGraphic.length;\n          var blackCount = board.blackStoneGraphic.length;\n\n          if (typeof this.randIndex === 'undefined') {\n            this.randIndex = Math.ceil(Math.random() * 1e5);\n          }\n\n          var redraw = function redraw() {\n            board.redraw();\n          }; // Check if image has been loaded properly\n          // see https://stereochro.me/ideas/detecting-broken-images-js\n\n\n          var isOkay = function isOkay(img) {\n            if (typeof img === 'string') {\n              return false;\n            }\n\n            if (!img.complete) {\n              return false;\n            }\n\n            if (typeof img.naturalWidth != \"undefined\" && img.naturalWidth == 0) {\n              return false;\n            }\n\n            return true;\n          };\n\n          if (args.c == WGo.W) {\n            var idx = this.randIndex % whiteCount;\n\n            if (typeof board.whiteStoneGraphic[idx] === 'string') {\n              // The image has not been loaded yet\n              var stoneGraphic = new Image(); // Redraw the whole board after the image has been loaded.\n              // This prevents 'missing stones' and similar graphical errors\n              // especially on slower internet connections.\n\n              stoneGraphic.onload = redraw;\n              stoneGraphic.src = board.whiteStoneGraphic[idx];\n              board.whiteStoneGraphic[idx] = stoneGraphic;\n            }\n\n            if (isOkay(board.whiteStoneGraphic[idx])) {\n              this.drawImage(board.whiteStoneGraphic[idx], xr - sr, yr - sr, 2 * sr, 2 * sr);\n            } else {\n              // Fall back to SHELL handler if there was a problem loading the image\n              Board.drawHandlers.SHELL.stone.draw.call(this, args, board);\n            }\n          } else {\n            // args.c == WGo.B\n            var idx = this.randIndex % blackCount;\n\n            if (typeof board.blackStoneGraphic[idx] === 'string') {\n              var stoneGraphic = new Image();\n              stoneGraphic.onload = redraw;\n              stoneGraphic.src = board.blackStoneGraphic[idx];\n              board.blackStoneGraphic[idx] = stoneGraphic;\n            }\n\n            if (isOkay(board.blackStoneGraphic[idx])) {\n              this.drawImage(board.blackStoneGraphic[idx], xr - sr, yr - sr, 2 * sr, 2 * sr);\n            } else {\n              Board.drawHandlers.SHELL.stone.draw.call(this, args, board);\n            }\n          }\n        }\n      },\n      shadow: shadow_handler_realistic\n    },\n    GLOW: {\n      stone: {\n        draw: function draw(args, board) {\n          var xr = board.getX(args.x),\n              yr = board.getY(args.y),\n              sr = board.stoneRadius;\n          var radgrad;\n\n          if (args.c == WGo.W) {\n            radgrad = this.createRadialGradient(xr - 2 * sr / 5, yr - 2 * sr / 5, sr / 3, xr - sr / 5, yr - sr / 5, 8 * sr / 5);\n            radgrad.addColorStop(0, '#fff');\n            radgrad.addColorStop(1, '#666');\n          } else {\n            radgrad = this.createRadialGradient(xr - 2 * sr / 5, yr - 2 * sr / 5, 1, xr - sr / 5, yr - sr / 5, 3 * sr / 5);\n            radgrad.addColorStop(0, '#555');\n            radgrad.addColorStop(1, '#000');\n          }\n\n          this.beginPath();\n          this.fillStyle = radgrad;\n          this.arc(xr - board.ls, yr - board.ls, Math.max(0, sr - 0.5), 0, 2 * Math.PI, true);\n          this.fill();\n        }\n      },\n      shadow: shadow_handler\n    },\n    SHELL: {\n      stone: {\n        draw: function draw(args, board) {\n          var xr,\n              yr,\n              sr = board.stoneRadius;\n          shell_seed = shell_seed || Math.ceil(Math.random() * 9999999);\n          xr = board.getX(args.x);\n          yr = board.getY(args.y);\n          var radgrad;\n\n          if (args.c == WGo.W) {\n            radgrad = \"#aaa\";\n          } else {\n            radgrad = \"#000\";\n          }\n\n          this.beginPath();\n          this.fillStyle = radgrad;\n          this.arc(xr - board.ls, yr - board.ls, Math.max(0, sr - 0.5), 0, 2 * Math.PI, true);\n          this.fill(); // do shell magic here\n\n          if (args.c == WGo.W) {\n            // do shell magic here\n            var type = shell_seed % (3 + args.x * board.size + args.y) % 3;\n            var z = board.size * board.size + args.x * board.size + args.y;\n            var angle = 2 / z * (shell_seed % z);\n\n            if (type == 0) {\n              draw_shell({\n                ctx: this,\n                x: xr,\n                y: yr,\n                radius: sr,\n                angle: angle,\n                lines: [0.10, 0.12, 0.11, 0.10, 0.09, 0.09, 0.09, 0.09],\n                factor: 0.25,\n                thickness: 1.75\n              });\n            } else if (type == 1) {\n              draw_shell({\n                ctx: this,\n                x: xr,\n                y: yr,\n                radius: sr,\n                angle: angle,\n                lines: [0.10, 0.09, 0.08, 0.07, 0.06, 0.06, 0.06, 0.06, 0.06, 0.06, 0.06],\n                factor: 0.2,\n                thickness: 1.5\n              });\n            } else {\n              draw_shell({\n                ctx: this,\n                x: xr,\n                y: yr,\n                radius: sr,\n                angle: angle,\n                lines: [0.12, 0.14, 0.13, 0.12, 0.12, 0.12],\n                factor: 0.3,\n                thickness: 2\n              });\n            }\n\n            radgrad = this.createRadialGradient(xr - 2 * sr / 5, yr - 2 * sr / 5, sr / 3, xr - sr / 5, yr - sr / 5, 5 * sr / 5);\n            radgrad.addColorStop(0, 'rgba(255,255,255,0.9)');\n            radgrad.addColorStop(1, 'rgba(255,255,255,0)'); // add radial gradient //\n\n            this.beginPath();\n            this.fillStyle = radgrad;\n            this.arc(xr - board.ls, yr - board.ls, Math.max(0, sr - 0.5), 0, 2 * Math.PI, true);\n            this.fill();\n          } else {\n            radgrad = this.createRadialGradient(xr + 0.4 * sr, yr + 0.4 * sr, 0, xr + 0.5 * sr, yr + 0.5 * sr, sr);\n            radgrad.addColorStop(0, 'rgba(32,32,32,1)');\n            radgrad.addColorStop(1, 'rgba(0,0,0,0)');\n            this.beginPath();\n            this.fillStyle = radgrad;\n            this.arc(xr - board.ls, yr - board.ls, Math.max(0, sr - 0.5), 0, 2 * Math.PI, true);\n            this.fill();\n            radgrad = this.createRadialGradient(xr - 0.4 * sr, yr - 0.4 * sr, 1, xr - 0.5 * sr, yr - 0.5 * sr, 1.5 * sr);\n            radgrad.addColorStop(0, 'rgba(64,64,64,1)');\n            radgrad.addColorStop(1, 'rgba(0,0,0,0)');\n            this.beginPath();\n            this.fillStyle = radgrad;\n            this.arc(xr - board.ls, yr - board.ls, Math.max(0, sr - 0.5), 0, 2 * Math.PI, true);\n            this.fill();\n          }\n        }\n      },\n      shadow: shadow_handler\n    },\n    MONO: {\n      stone: {\n        draw: function draw(args, board) {\n          var xr = board.getX(args.x),\n              yr = board.getY(args.y),\n              sr = board.stoneRadius,\n              lw = theme_variable(\"markupLinesWidth\", board) || 1;\n          if (args.c == WGo.W) this.fillStyle = \"white\";else this.fillStyle = \"black\";\n          this.beginPath();\n          this.arc(xr, yr, Math.max(0, sr - lw), 0, 2 * Math.PI, true);\n          this.fill();\n          this.lineWidth = lw;\n          this.strokeStyle = \"black\";\n          this.stroke();\n        }\n      }\n    },\n    CR: {\n      stone: {\n        draw: function draw(args, board) {\n          var xr = board.getX(args.x),\n              yr = board.getY(args.y),\n              sr = board.stoneRadius;\n          this.strokeStyle = args.c || get_markup_color(board, args.x, args.y);\n          this.lineWidth = args.lineWidth || theme_variable(\"markupLinesWidth\", board) || 1;\n          this.beginPath();\n          this.arc(xr - board.ls, yr - board.ls, sr / 2, 0, 2 * Math.PI, true);\n          this.stroke();\n        }\n      }\n    },\n    // Label drawing handler\n    LB: {\n      stone: {\n        draw: function draw(args, board) {\n          var xr = board.getX(args.x),\n              yr = board.getY(args.y),\n              sr = board.stoneRadius,\n              font = args.font || theme_variable(\"font\", board) || \"\";\n          this.fillStyle = args.c || get_markup_color(board, args.x, args.y);\n          if (args.text.length == 1) this.font = Math.round(sr * 1.5) + \"px \" + font;else if (args.text.length == 2) this.font = Math.round(sr * 1.2) + \"px \" + font;else this.font = Math.round(sr) + \"px \" + font;\n          this.beginPath();\n          this.textBaseline = \"middle\";\n          this.textAlign = \"center\";\n          this.fillText(args.text, xr, yr, 2 * sr);\n        }\n      },\n      // modifies grid layer too\n      grid: {\n        draw: function draw(args, board) {\n          if (!is_here_stone(board, args.x, args.y) && !args._nodraw) {\n            var xr = board.getX(args.x),\n                yr = board.getY(args.y),\n                sr = board.stoneRadius;\n            this.clearRect(xr - sr, yr - sr, 2 * sr, 2 * sr);\n          }\n        },\n        clear: function clear(args, board) {\n          if (!is_here_stone(board, args.x, args.y)) {\n            args._nodraw = true;\n            redraw_layer(board, \"grid\");\n            delete args._nodraw;\n          }\n        }\n      }\n    },\n    SQ: {\n      stone: {\n        draw: function draw(args, board) {\n          var xr = board.getX(args.x),\n              yr = board.getY(args.y),\n              sr = Math.round(board.stoneRadius);\n          this.strokeStyle = args.c || get_markup_color(board, args.x, args.y);\n          this.lineWidth = args.lineWidth || theme_variable(\"markupLinesWidth\", board) || 1;\n          this.beginPath();\n          this.rect(Math.round(xr - sr / 2) - board.ls, Math.round(yr - sr / 2) - board.ls, sr, sr);\n          this.stroke();\n        }\n      }\n    },\n    TR: {\n      stone: {\n        draw: function draw(args, board) {\n          var xr = board.getX(args.x),\n              yr = board.getY(args.y),\n              sr = board.stoneRadius;\n          this.strokeStyle = args.c || get_markup_color(board, args.x, args.y);\n          this.lineWidth = args.lineWidth || theme_variable(\"markupLinesWidth\", board) || 1;\n          this.beginPath();\n          this.moveTo(xr - board.ls, yr - board.ls - Math.round(sr / 2));\n          this.lineTo(Math.round(xr - sr / 2) - board.ls, Math.round(yr + sr / 3) + board.ls);\n          this.lineTo(Math.round(xr + sr / 2) + board.ls, Math.round(yr + sr / 3) + board.ls);\n          this.closePath();\n          this.stroke();\n        }\n      }\n    },\n    MA: {\n      stone: {\n        draw: function draw(args, board) {\n          var xr = board.getX(args.x),\n              yr = board.getY(args.y),\n              sr = board.stoneRadius;\n          this.strokeStyle = args.c || get_markup_color(board, args.x, args.y);\n          this.lineCap = \"round\";\n          this.lineWidth = (args.lineWidth || theme_variable(\"markupLinesWidth\", board) || 1) * 2 - 1;\n          this.beginPath();\n          this.moveTo(Math.round(xr - sr / 2), Math.round(yr - sr / 2));\n          this.lineTo(Math.round(xr + sr / 2), Math.round(yr + sr / 2));\n          this.moveTo(Math.round(xr + sr / 2) - 1, Math.round(yr - sr / 2));\n          this.lineTo(Math.round(xr - sr / 2) - 1, Math.round(yr + sr / 2));\n          this.stroke();\n          this.lineCap = \"butt\";\n        }\n      }\n    },\n    SL: {\n      stone: {\n        draw: function draw(args, board) {\n          var xr = board.getX(args.x),\n              yr = board.getY(args.y),\n              sr = board.stoneRadius;\n          this.fillStyle = args.c || get_markup_color(board, args.x, args.y);\n          this.beginPath();\n          this.rect(xr - sr / 2, yr - sr / 2, sr, sr);\n          this.fill();\n        }\n      }\n    },\n    SM: {\n      stone: {\n        draw: function draw(args, board) {\n          var xr = board.getX(args.x),\n              yr = board.getY(args.y),\n              sr = board.stoneRadius;\n          this.strokeStyle = args.c || get_markup_color(board, args.x, args.y);\n          this.lineWidth = (args.lineWidth || theme_variable(\"markupLinesWidth\", board) || 1) * 2;\n          this.beginPath();\n          this.arc(xr - sr / 3, yr - sr / 3, sr / 6, 0, 2 * Math.PI, true);\n          this.stroke();\n          this.beginPath();\n          this.arc(xr + sr / 3, yr - sr / 3, sr / 6, 0, 2 * Math.PI, true);\n          this.stroke();\n          this.beginPath();\n          this.moveTo(xr - sr / 1.5, yr);\n          this.bezierCurveTo(xr - sr / 1.5, yr + sr / 2, xr + sr / 1.5, yr + sr / 2, xr + sr / 1.5, yr);\n          this.stroke();\n        }\n      }\n    },\n    outline: {\n      stone: {\n        draw: function draw(args, board) {\n          if (args.alpha) this.globalAlpha = args.alpha;else this.globalAlpha = 0.3;\n          if (args.stoneStyle) Board.drawHandlers[args.stoneStyle].stone.draw.call(this, args, board);else board.stoneHandler.stone.draw.call(this, args, board);\n          this.globalAlpha = 1;\n        }\n      }\n    },\n    mini: {\n      stone: {\n        draw: function draw(args, board) {\n          board.stoneRadius = board.stoneRadius / 2;\n          if (args.stoneStyle) Board.drawHandlers[args.stoneStyle].stone.draw.call(this, args, board);else board.stoneHandler.stone.draw.call(this, args, board);\n          board.stoneRadius = board.stoneRadius * 2;\n        }\n      }\n    }\n  };\n  Board.coordinates = {\n    grid: {\n      draw: function draw(args, board) {\n        var ch, t, xright, xleft, ytop, ybottom;\n        this.fillStyle = theme_variable(\"coordinatesColor\", board);\n        this.textBaseline = \"middle\";\n        this.textAlign = \"center\";\n        this.font = board.stoneRadius + \"px \" + (board.font || \"\");\n        xright = board.getX(-0.75);\n        xleft = board.getX(board.size - 0.25);\n        ytop = board.getY(-0.75);\n        ybottom = board.getY(board.size - 0.25);\n\n        for (var i = 0; i < board.size; i++) {\n          ch = i + \"A\".charCodeAt(0);\n          if (ch >= \"I\".charCodeAt(0)) ch++;\n          t = board.getY(i);\n          this.fillText(board.size - i, xright, t);\n          this.fillText(board.size - i, xleft, t);\n          t = board.getX(i);\n          this.fillText(String.fromCharCode(ch), t, ytop);\n          this.fillText(String.fromCharCode(ch), t, ybottom);\n        }\n\n        this.fillStyle = \"black\";\n      }\n    }\n  };\n\n  Board.CanvasLayer = function () {\n    this.element = document.createElement('canvas');\n    this.context = this.element.getContext('2d'); // Adjust pixel ratio for HDPI screens (e.g. Retina)\n\n    this.pixelRatio = window.devicePixelRatio || 1;\n\n    if (this.pixelRatio > 1) {\n      this.context.scale(this.pixelRatio, this.pixelRatio);\n    }\n  };\n\n  Board.CanvasLayer.prototype = {\n    constructor: Board.CanvasLayer,\n    setDimensions: function setDimensions(width, height) {\n      this.element.width = width;\n      this.element.style.width = width / this.pixelRatio + 'px';\n      this.element.height = height;\n      this.element.style.height = height / this.pixelRatio + 'px';\n    },\n    appendTo: function appendTo(element, weight) {\n      this.element.style.position = 'absolute';\n      this.element.style.zIndex = weight;\n      element.appendChild(this.element);\n    },\n    removeFrom: function removeFrom(element) {\n      element.removeChild(this.element);\n    },\n    getContext: function getContext() {\n      return this.context;\n    },\n    draw: function draw(board) {},\n    clear: function clear() {\n      this.context.clearRect(0, 0, this.element.width, this.element.height);\n    }\n  };\n  Board.GridLayer = WGo.extendClass(Board.CanvasLayer, function () {\n    this[\"super\"].call(this);\n  });\n\n  Board.GridLayer.prototype.draw = function (board) {\n    // draw grid\n    var tmp;\n    this.context.beginPath();\n    this.context.lineWidth = theme_variable(\"gridLinesWidth\", board);\n    this.context.strokeStyle = theme_variable(\"gridLinesColor\", board);\n    var tx = Math.round(board.left),\n        ty = Math.round(board.top),\n        bw = Math.round(board.fieldWidth * (board.size - 1)),\n        bh = Math.round(board.fieldHeight * (board.size - 1));\n    this.context.strokeRect(tx - board.ls, ty - board.ls, bw, bh);\n\n    for (var i = 1; i < board.size - 1; i++) {\n      tmp = Math.round(board.getX(i)) - board.ls;\n      this.context.moveTo(tmp, ty);\n      this.context.lineTo(tmp, ty + bh);\n      tmp = Math.round(board.getY(i)) - board.ls;\n      this.context.moveTo(tx, tmp);\n      this.context.lineTo(tx + bw, tmp);\n    }\n\n    this.context.stroke(); // draw stars\n\n    this.context.fillStyle = theme_variable(\"starColor\", board);\n\n    if (board.starPoints[board.size]) {\n      for (var key in board.starPoints[board.size]) {\n        this.context.beginPath();\n        this.context.arc(board.getX(board.starPoints[board.size][key].x) - board.ls, board.getY(board.starPoints[board.size][key].y) - board.ls, theme_variable(\"starSize\", board), 0, 2 * Math.PI, true);\n        this.context.fill();\n      }\n    }\n  };\n  /**\n   * Layer that is composed from more canvases. The proper canvas is selected according to drawn object.\n   * In default there are 4 canvases and they are used for board objects like stones. This allows overlapping of objects.\n   */\n\n\n  Board.MultipleCanvasLayer = WGo.extendClass(Board.CanvasLayer, function () {\n    this.init(4);\n  });\n\n  Board.MultipleCanvasLayer.prototype.init = function (n) {\n    var tmp, tmpContext;\n    this.layers = n;\n    this.elements = [];\n    this.contexts = []; // Adjust pixel ratio for HDPI screens (e.g. Retina)\n\n    this.pixelRatio = window.devicePixelRatio || 1;\n\n    for (var i = 0; i < n; i++) {\n      tmp = document.createElement('canvas');\n      tmpContext = tmp.getContext('2d');\n\n      if (this.pixelRatio > 1) {\n        tmpContext.scale(this.pixelRatio, this.pixelRatio);\n      }\n\n      this.elements.push(tmp);\n      this.contexts.push(tmpContext);\n    }\n  };\n\n  Board.MultipleCanvasLayer.prototype.appendTo = function (element, weight) {\n    for (var i = 0; i < this.layers; i++) {\n      this.elements[i].style.position = 'absolute';\n      this.elements[i].style.zIndex = weight;\n      element.appendChild(this.elements[i]);\n    }\n  };\n\n  Board.MultipleCanvasLayer.prototype.removeFrom = function (element) {\n    for (var i = 0; i < this.layers; i++) {\n      element.removeChild(this.elements[i]);\n    }\n  };\n\n  Board.MultipleCanvasLayer.prototype.getContext = function (args) {\n    if (args.x % 2) {\n      return args.y % 2 ? this.contexts[0] : this.contexts[1];\n    } else {\n      return args.y % 2 ? this.contexts[2] : this.contexts[3];\n    } //return ((args.x%2) && (args.y%2) || !(args.x%2) && !(args.y%2)) ? this.context_odd : this.context_even;\n\n  };\n\n  Board.MultipleCanvasLayer.prototype.clear = function (element, weight) {\n    for (var i = 0; i < this.layers; i++) {\n      this.contexts[i].clearRect(0, 0, this.elements[i].width, this.elements[i].height);\n    }\n  };\n\n  Board.MultipleCanvasLayer.prototype.setDimensions = function (width, height) {\n    for (var i = 0; i < this.layers; i++) {\n      this.elements[i].width = width;\n      this.elements[i].style.width = width / this.pixelRatio + 'px';\n      this.elements[i].height = height;\n      this.elements[i].style.height = height / this.pixelRatio + 'px';\n    }\n  };\n\n  Board.ShadowLayer = WGo.extendClass(Board.MultipleCanvasLayer, function (board, shadowSize, shadowBlur) {\n    this.init(2);\n    this.shadowSize = shadowSize === undefined ? 1 : shadowSize;\n    this.board = board;\n  });\n\n  Board.ShadowLayer.prototype.getContext = function (args) {\n    return args.x % 2 && args.y % 2 || !(args.x % 2) && !(args.y % 2) ? this.contexts[0] : this.contexts[1];\n  };\n\n  Board.ShadowLayer.prototype.setDimensions = function (width, height) {\n    this[\"super\"].prototype.setDimensions.call(this, width, height);\n\n    for (var i = 0; i < this.layers; i++) {\n      this.contexts[i].setTransform(1, 0, 0, 1, Math.round(this.shadowSize * this.board.stoneRadius / 7), Math.round(this.shadowSize * this.board.stoneRadius / 7));\n    }\n  };\n\n  var default_field_clear = function default_field_clear(args, board) {\n    var xr = board.getX(args.x),\n        yr = board.getY(args.y),\n        sr = board.stoneRadius;\n    this.clearRect(xr - 2 * sr - board.ls, yr - 2 * sr - board.ls, 4 * sr, 4 * sr);\n  }; // Private methods of WGo.Board\n\n\n  var calcLeftMargin = function calcLeftMargin() {\n    return 3 * this.width / (4 * (this.bx + 1 - this.tx) + 2) - this.fieldWidth * this.tx;\n  };\n\n  var calcTopMargin = function calcTopMargin() {\n    return 3 * this.height / (4 * (this.by + 1 - this.ty) + 2) - this.fieldHeight * this.ty;\n  };\n\n  var calcFieldWidth = function calcFieldWidth() {\n    return 4 * this.width / (4 * (this.bx + 1 - this.tx) + 2);\n  };\n\n  var calcFieldHeight = function calcFieldHeight() {\n    return 4 * this.height / (4 * (this.by + 1 - this.ty) + 2);\n  };\n\n  var clearField = function clearField(x, y) {\n    var handler;\n\n    for (var z = 0; z < this.obj_arr[x][y].length; z++) {\n      var obj = this.obj_arr[x][y][z];\n      if (!obj.type) handler = this.stoneHandler;else if (typeof obj.type == \"string\") handler = Board.drawHandlers[obj.type];else handler = obj.type;\n\n      for (var layer in handler) {\n        if (handler[layer].clear) handler[layer].clear.call(this[layer].getContext(obj), obj, this);else default_field_clear.call(this[layer].getContext(obj), obj, this);\n      }\n    }\n  };\n\n  var drawField = function drawField(x, y) {\n    var handler;\n\n    for (var z = 0; z < this.obj_arr[x][y].length; z++) {\n      var obj = this.obj_arr[x][y][z];\n      if (!obj.type) handler = this.stoneHandler;else if (typeof obj.type == \"string\") handler = Board.drawHandlers[obj.type];else handler = obj.type;\n\n      for (var layer in handler) {\n        handler[layer].draw.call(this[layer].getContext(obj), obj, this);\n      }\n    }\n  };\n\n  var getMousePos = function getMousePos(e) {\n    // new hopefully better translation of coordinates\n    var x, y;\n    x = e.offsetX * this.pixelRatio;\n    x -= this.left;\n    x /= this.fieldWidth;\n    x = Math.round(x);\n    y = e.offsetY * this.pixelRatio;\n    y -= this.top;\n    y /= this.fieldHeight;\n    y = Math.round(y);\n    return {\n      x: x >= this.size ? -1 : x,\n      y: y >= this.size ? -1 : y\n    };\n  };\n\n  var updateDim = function updateDim() {\n    this.element.style.width = this.width / this.pixelRatio + \"px\";\n    this.element.style.height = this.height / this.pixelRatio + \"px\";\n    this.stoneRadius = theme_variable(\"stoneSize\", this); //if(this.autoLineWidth) this.lineWidth = this.stoneRadius/7; //< 15 ? 1 : 3;\n\n    this.ls = theme_variable(\"linesShift\", this);\n\n    for (var i = 0; i < this.layers.length; i++) {\n      this.layers[i].setDimensions(this.width, this.height);\n    }\n  }; // Public methods are in the prototype:\n\n\n  Board.prototype = {\n    constructor: Board,\n\n    /**\n        * Initialization method, it is called in constructor. You shouldn't call it, but you can alter it.\n     */\n    init: function init() {\n      // placement of objects (in 3D array)\n      this.obj_arr = [];\n\n      for (var i = 0; i < this.size; i++) {\n        this.obj_arr[i] = [];\n\n        for (var j = 0; j < this.size; j++) {\n          this.obj_arr[i][j] = [];\n        }\n      } // other objects, stored in list\n\n\n      this.obj_list = []; // layers\n\n      this.layers = []; // event listeners, binded to board\n\n      this.listeners = [];\n      this.element = document.createElement('div');\n      this.element.className = 'wgo-board';\n      this.element.style.position = 'relative';\n\n      if (this.background) {\n        if (this.background[0] == \"#\") this.element.style.backgroundColor = this.background;else {\n          this.element.style.backgroundImage = \"url('\" + this.background + \"')\";\n          /*this.element.style.backgroundRepeat = \"repeat\";*/\n\n          if (this.stoneHandler == Board.drawHandlers.REALISTIC) {\n            // The photographed wood images do not repeat and are the size of an actual\n            // Go-Board. Therefore scale to fit.\n            this.element.style.backgroundSize = \"100%\";\n          }\n        }\n      }\n\n      this.grid = new Board.GridLayer();\n      this.shadow = new Board.ShadowLayer(this, theme_variable(\"shadowSize\", this));\n      this.stone = new Board.MultipleCanvasLayer();\n      this.addLayer(this.grid, 100);\n      this.addLayer(this.shadow, 200);\n      this.addLayer(this.stone, 300);\n    },\n\n    /**\n     * Set new width of board, height is computed to keep aspect ratio.\n     *\n     * @param {number} width\n     */\n    setWidth: function setWidth(width) {\n      this.width = width;\n      this.width *= this.pixelRatio;\n      this.fieldHeight = this.fieldWidth = calcFieldWidth.call(this);\n      this.left = calcLeftMargin.call(this);\n      this.height = (this.by - this.ty + 1.5) * this.fieldHeight;\n      this.top = calcTopMargin.call(this);\n      updateDim.call(this);\n      this.redraw();\n    },\n\n    /**\n     * Set new height of board, width is computed to keep aspect ratio.\n     *\n     * @param {number} height\n     */\n    setHeight: function setHeight(height) {\n      this.height = height;\n      this.height *= this.pixelRatio;\n      this.fieldWidth = this.fieldHeight = calcFieldHeight.call(this);\n      this.top = calcTopMargin.call(this);\n      this.width = (this.bx - this.tx + 1.5) * this.fieldWidth;\n      this.left = calcLeftMargin.call(this);\n      updateDim.call(this);\n      this.redraw();\n    },\n\n    /**\n     * Set both dimensions.\n     *\n     * @param {number} width\n     * @param {number} height\n     */\n    setDimensions: function setDimensions(width, height) {\n      this.width = width || parseInt(this.element.style.width, 10);\n      this.width *= this.pixelRatio;\n      this.height = height || parseInt(this.element.style.height, 10);\n      this.height *= this.pixelRatio;\n      this.fieldWidth = calcFieldWidth.call(this);\n      this.fieldHeight = calcFieldHeight.call(this);\n      this.left = calcLeftMargin.call(this);\n      this.top = calcTopMargin.call(this);\n      updateDim.call(this);\n      this.redraw();\n    },\n\n    /**\n     * Get currently visible section of the board\n     */\n    getSection: function getSection() {\n      return this.section;\n    },\n\n    /**\n     * Set section of the board to be displayed\n     */\n    setSection: function setSection(section_or_top, right, bottom, left) {\n      if (_typeof(section_or_top) == \"object\") {\n        this.section = section_or_top;\n      } else {\n        this.section = {\n          top: section_or_top,\n          right: right,\n          bottom: bottom,\n          left: left\n        };\n      }\n\n      this.tx = this.section.left;\n      this.ty = this.section.top;\n      this.bx = this.size - 1 - this.section.right;\n      this.by = this.size - 1 - this.section.bottom;\n      this.setDimensions();\n    },\n\n    /**\n     * Set board size (eg: 9, 13 or 19), this will clear board's objects.\n     */\n    setSize: function setSize(size) {\n      var size = size || 19;\n\n      if (size != this.size) {\n        this.size = size;\n        this.obj_arr = [];\n\n        for (var i = 0; i < this.size; i++) {\n          this.obj_arr[i] = [];\n\n          for (var j = 0; j < this.size; j++) {\n            this.obj_arr[i][j] = [];\n          }\n        }\n\n        this.bx = this.size - 1 - this.section.right;\n        this.by = this.size - 1 - this.section.bottom;\n        this.setDimensions();\n      }\n    },\n\n    /**\n     * Redraw everything.\n     */\n    redraw: function redraw() {\n      try {\n        // redraw layers\n        for (var i = 0; i < this.layers.length; i++) {\n          this.layers[i].clear(this);\n          this.layers[i].draw(this);\n        } // redraw field objects\n\n\n        for (var i = 0; i < this.size; i++) {\n          for (var j = 0; j < this.size; j++) {\n            drawField.call(this, i, j);\n          }\n        } // redraw custom objects\n\n\n        for (var i = 0; i < this.obj_list.length; i++) {\n          var obj = this.obj_list[i];\n          var handler = obj.handler;\n\n          for (var layer in handler) {\n            handler[layer].draw.call(this[layer].getContext(obj.args), obj.args, this);\n          }\n        }\n      } catch (err) {\n        // If the board is too small some canvas painting function can throw an exception, but we don't want to break our app\n        console.log(\"WGo board failed to render. Error: \" + err.message);\n      }\n    },\n\n    /**\n     * Get absolute X coordinate\n     *\n     * @param {number} x relative coordinate\n     */\n    getX: function getX(x) {\n      return this.left + x * this.fieldWidth;\n    },\n\n    /**\n     * Get absolute Y coordinate\n     *\n     * @param {number} y relative coordinate\n     */\n    getY: function getY(y) {\n      return this.top + y * this.fieldHeight;\n    },\n\n    /**\n     * Add layer to the board. It is meant to be only for canvas layers.\n     *\n     * @param {Board.CanvasLayer} layer to add\n     * @param {number} weight layer with biggest weight is on the top\n     */\n    addLayer: function addLayer(layer, weight) {\n      layer.appendTo(this.element, weight);\n      layer.setDimensions(this.width, this.height);\n      this.layers.push(layer);\n    },\n\n    /**\n     * Remove layer from the board.\n     *\n     * @param {Board.CanvasLayer} layer to remove\n     */\n    removeLayer: function removeLayer(layer) {\n      var i = this.layers.indexOf(layer);\n\n      if (i >= 0) {\n        this.layers.splice(i, 1);\n        layer.removeFrom(this.element);\n      }\n    },\n    update: function update(changes) {\n      var i;\n      if (changes.remove && changes.remove == \"all\") this.removeAllObjects();else if (changes.remove) {\n        for (i = 0; i < changes.remove.length; i++) {\n          this.removeObject(changes.remove[i]);\n        }\n      }\n\n      if (changes.add) {\n        for (i = 0; i < changes.add.length; i++) {\n          this.addObject(changes.add[i]);\n        }\n      }\n    },\n    addObject: function addObject(obj) {\n      // handling multiple objects\n      if (obj.constructor == Array) {\n        for (var i = 0; i < obj.length; i++) {\n          this.addObject(obj[i]);\n        }\n\n        return;\n      }\n\n      try {\n        // clear all objects on object's coordinates\n        clearField.call(this, obj.x, obj.y); // if object of this type is on the board, replace it\n\n        var layers = this.obj_arr[obj.x][obj.y];\n\n        for (var z = 0; z < layers.length; z++) {\n          if (layers[z].type == obj.type) {\n            layers[z] = obj;\n            drawField.call(this, obj.x, obj.y);\n            return;\n          }\n        } // if object is a stone, add it at the beginning, otherwise at the end\n\n\n        if (!obj.type) layers.unshift(obj);else layers.push(obj); // draw all objects\n\n        drawField.call(this, obj.x, obj.y);\n      } catch (err) {\n        // If the board is too small some canvas painting function can throw an exception, but we don't want to break our app\n        console.log(\"WGo board failed to render. Error: \" + err.message);\n      }\n    },\n    removeObject: function removeObject(obj) {\n      // handling multiple objects\n      if (obj.constructor == Array) {\n        for (var n = 0; n < obj.length; n++) {\n          this.removeObject(obj[n]);\n        }\n\n        return;\n      }\n\n      try {\n        var i;\n\n        for (var j = 0; j < this.obj_arr[obj.x][obj.y].length; j++) {\n          if (this.obj_arr[obj.x][obj.y][j].type == obj.type) {\n            i = j;\n            break;\n          }\n        }\n\n        if (i === undefined) return; // clear all objects on object's coordinates\n\n        clearField.call(this, obj.x, obj.y);\n        this.obj_arr[obj.x][obj.y].splice(i, 1);\n        drawField.call(this, obj.x, obj.y);\n      } catch (err) {\n        // If the board is too small some canvas painting function can throw an exception, but we don't want to break our app\n        console.log(\"WGo board failed to render. Error: \" + err.message);\n      }\n    },\n    removeObjectsAt: function removeObjectsAt(x, y) {\n      if (!this.obj_arr[x][y].length) return;\n      clearField.call(this, x, y);\n      this.obj_arr[x][y] = [];\n    },\n    removeAllObjects: function removeAllObjects() {\n      this.obj_arr = [];\n\n      for (var i = 0; i < this.size; i++) {\n        this.obj_arr[i] = [];\n\n        for (var j = 0; j < this.size; j++) {\n          this.obj_arr[i][j] = [];\n        }\n      }\n\n      this.redraw();\n    },\n    addCustomObject: function addCustomObject(handler, args) {\n      this.obj_list.push({\n        handler: handler,\n        args: args\n      });\n      this.redraw();\n    },\n    removeCustomObject: function removeCustomObject(handler, args) {\n      for (var i = 0; i < this.obj_list.length; i++) {\n        var obj = this.obj_list[i];\n\n        if (obj.handler == handler && obj.args == args) {\n          this.obj_list.splice(i, 1);\n          this.redraw();\n          return true;\n        }\n      }\n\n      return false;\n    },\n    addEventListener: function addEventListener(type, callback) {\n      var _this = this,\n          evListener = {\n        type: type,\n        callback: callback,\n        handleEvent: function handleEvent(e) {\n          var coo = getMousePos.call(_this, e);\n          callback(coo.x, coo.y, e);\n        }\n      };\n\n      this.element.addEventListener(type, evListener, true);\n      this.listeners.push(evListener);\n    },\n    removeEventListener: function removeEventListener(type, callback) {\n      for (var i = 0; i < this.listeners.length; i++) {\n        var listener = this.listeners[i];\n\n        if (listener.type == type && listener.callback == callback) {\n          this.element.removeEventListener(listener.type, listener, true);\n          this.listeners.splice(i, 1);\n          return true;\n        }\n      }\n\n      return false;\n    },\n    getState: function getState() {\n      return {\n        objects: WGo.clone(this.obj_arr),\n        custom: WGo.clone(this.obj_list)\n      };\n    },\n    restoreState: function restoreState(state) {\n      this.obj_arr = state.objects || this.obj_arr;\n      this.obj_list = state.custom || this.obj_list;\n      this.redraw();\n    }\n  };\n  Board[\"default\"] = {\n    size: 19,\n    width: 0,\n    height: 0,\n    font: \"Calibri\",\n    // deprecated\n    lineWidth: 1,\n    // deprecated\n    autoLineWidth: false,\n    // deprecated\n    starPoints: {\n      5: [{\n        x: 2,\n        y: 2\n      }],\n      7: [{\n        x: 3,\n        y: 3\n      }],\n      8: [{\n        x: 2,\n        y: 2\n      }, {\n        x: 5,\n        y: 2\n      }, {\n        x: 2,\n        y: 5\n      }, {\n        x: 5,\n        y: 5\n      }],\n      9: [{\n        x: 2,\n        y: 2\n      }, {\n        x: 6,\n        y: 2\n      }, {\n        x: 4,\n        y: 4\n      }, {\n        x: 2,\n        y: 6\n      }, {\n        x: 6,\n        y: 6\n      }],\n      10: [{\n        x: 2,\n        y: 2\n      }, {\n        x: 7,\n        y: 2\n      }, {\n        x: 2,\n        y: 7\n      }, {\n        x: 7,\n        y: 7\n      }],\n      11: [{\n        x: 2,\n        y: 2\n      }, {\n        x: 8,\n        y: 2\n      }, {\n        x: 5,\n        y: 5\n      }, {\n        x: 2,\n        y: 8\n      }, {\n        x: 8,\n        y: 8\n      }],\n      12: [{\n        x: 3,\n        y: 3\n      }, {\n        x: 8,\n        y: 3\n      }, {\n        x: 3,\n        y: 8\n      }, {\n        x: 8,\n        y: 8\n      }],\n      13: [{\n        x: 3,\n        y: 3\n      }, {\n        x: 9,\n        y: 3\n      }, {\n        x: 6,\n        y: 6\n      }, {\n        x: 3,\n        y: 9\n      }, {\n        x: 9,\n        y: 9\n      }],\n      14: [{\n        x: 3,\n        y: 3\n      }, {\n        x: 10,\n        y: 3\n      }, {\n        x: 3,\n        y: 10\n      }, {\n        x: 10,\n        y: 10\n      }],\n      15: [{\n        x: 3,\n        y: 3\n      }, {\n        x: 11,\n        y: 3\n      }, {\n        x: 7,\n        y: 7\n      }, {\n        x: 3,\n        y: 11\n      }, {\n        x: 11,\n        y: 11\n      }],\n      16: [{\n        x: 3,\n        y: 3\n      }, {\n        x: 12,\n        y: 3\n      }, {\n        x: 3,\n        y: 12\n      }, {\n        x: 12,\n        y: 12\n      }],\n      17: [{\n        x: 3,\n        y: 3\n      }, {\n        x: 8,\n        y: 3\n      }, {\n        x: 13,\n        y: 3\n      }, {\n        x: 3,\n        y: 8\n      }, {\n        x: 8,\n        y: 8\n      }, {\n        x: 13,\n        y: 8\n      }, {\n        x: 3,\n        y: 13\n      }, {\n        x: 8,\n        y: 13\n      }, {\n        x: 13,\n        y: 13\n      }],\n      18: [{\n        x: 3,\n        y: 3\n      }, {\n        x: 14,\n        y: 3\n      }, {\n        x: 3,\n        y: 14\n      }, {\n        x: 14,\n        y: 14\n      }],\n      19: [{\n        x: 3,\n        y: 3\n      }, {\n        x: 9,\n        y: 3\n      }, {\n        x: 15,\n        y: 3\n      }, {\n        x: 3,\n        y: 9\n      }, {\n        x: 9,\n        y: 9\n      }, {\n        x: 15,\n        y: 9\n      }, {\n        x: 3,\n        y: 15\n      }, {\n        x: 9,\n        y: 15\n      }, {\n        x: 15,\n        y: 15\n      }],\n      20: [{\n        x: 3,\n        y: 3\n      }, {\n        x: 16,\n        y: 3\n      }, {\n        x: 3,\n        y: 16\n      }, {\n        x: 16,\n        y: 16\n      }],\n      21: [{\n        x: 3,\n        y: 3\n      }, {\n        x: 10,\n        y: 3\n      }, {\n        x: 17,\n        y: 3\n      }, {\n        x: 3,\n        y: 10\n      }, {\n        x: 10,\n        y: 10\n      }, {\n        x: 17,\n        y: 10\n      }, {\n        x: 3,\n        y: 17\n      }, {\n        x: 10,\n        y: 17\n      }, {\n        x: 17,\n        y: 17\n      }]\n    },\n    //stoneHandler: Board.drawHandlers.SHELL,\n    stoneHandler: Board.drawHandlers.REALISTIC,\n    // New photograph based stones\n    starSize: 1,\n    // deprecated\n    shadowSize: 1,\n    // deprecated\n    stoneSize: 1,\n    // deprecated\n    section: {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    },\n    //background: WGo.DIR+\"wood1.jpg\",    // Original version, tileing\n    //background: WGo.DIR+\"wood_512.jpg\", // Mobile friendly, low resolution\n    background: WGo.DIR + \"wood_1024.jpg\",\n    // High resolution version, use with REALISTIC handler\n    //whiteStoneGraphic: [ WGo.DIR+\"white_128.png\" ], // Single image only, hires\n    //blackStoneGraphic: [ WGo.DIR+\"black_128.png\" ], // Single image only, hires\n    //whiteStoneGraphic: [ WGo.DIR+\"white_64.png\" ], // Single image only, lowres\n    //blackStoneGraphic: [ WGo.DIR+\"black_64.png\" ], // Single image only, lowres\n    whiteStoneGraphic: [WGo.DIR + \"stones/white00_128.png\", WGo.DIR + \"stones/white01_128.png\", WGo.DIR + \"stones/white02_128.png\", WGo.DIR + \"stones/white03_128.png\", WGo.DIR + \"stones/white04_128.png\", WGo.DIR + \"stones/white05_128.png\", WGo.DIR + \"stones/white06_128.png\", WGo.DIR + \"stones/white07_128.png\", WGo.DIR + \"stones/white08_128.png\", WGo.DIR + \"stones/white09_128.png\", WGo.DIR + \"stones/white10_128.png\"],\n    blackStoneGraphic: [WGo.DIR + \"stones/black00_128.png\", WGo.DIR + \"stones/black01_128.png\", WGo.DIR + \"stones/black02_128.png\", WGo.DIR + \"stones/black03_128.png\"],\n    theme: {}\n  }; // save Board\n\n  WGo.Board = Board; //-------- WGo.Game ---------------------------------------------------------------------------\n\n  /**\n   * Creates instance of position object.\n   *\n   * @class\n   * <p>WGo.Position is simple object storing position of go game. It is implemented as matrix <em>size</em> x <em>size</em> with values WGo.BLACK, WGo.WHITE or 0. It can be used by any extension.</p>\n   *\n   * @param {number} size of the board\n   */\n\n  var Position = function Position(size) {\n    this.size = size || 19;\n    this.schema = [];\n\n    for (var i = 0; i < this.size * this.size; i++) {\n      this.schema[i] = 0;\n    }\n  };\n\n  Position.prototype = {\n    constructor: WGo.Position,\n\n    /**\n     * Returns value of given coordinates.\n     *\n     * @param {number} x coordinate\n     * @param {number} y coordinate\n     * @return {(WGo.BLACK|WGo.WHITE|0)} color\n     */\n    get: function get(x, y) {\n      if (x < 0 || y < 0 || x >= this.size || y >= this.size) return undefined;\n      return this.schema[x * this.size + y];\n    },\n\n    /**\n     * Sets value of given coordinates.\n     *\n     * @param {number} x coordinate\n     * @param {number} y coordinate\n     * @param {(WGo.B|WGo.W|0)} c color\n     */\n    set: function set(x, y, c) {\n      this.schema[x * this.size + y] = c;\n      return this;\n    },\n\n    /**\n     * Clears the whole position (every value is set to 0).\n     */\n    clear: function clear() {\n      for (var i = 0; i < this.size * this.size; i++) {\n        this.schema[i] = 0;\n      }\n\n      return this;\n    },\n\n    /**\n     * Clones the whole position.\n     *\n     * @return {WGo.Position} copy of position\n     */\n    clone: function clone() {\n      var clone = new Position(this.size);\n      clone.schema = this.schema.slice(0);\n      return clone;\n    },\n\n    /**\n     * Compares this position with another position and return change object\n     *\n     * @param {WGo.Position} position to compare to.\n     * @return {object} change object with structure: {add:[], remove:[]}\n     */\n    compare: function compare(position) {\n      var add = [],\n          remove = [];\n\n      for (var i = 0; i < this.size * this.size; i++) {\n        if (this.schema[i] && !position.schema[i]) remove.push({\n          x: Math.floor(i / this.size),\n          y: i % this.size\n        });else if (this.schema[i] != position.schema[i]) add.push({\n          x: Math.floor(i / this.size),\n          y: i % this.size,\n          c: position.schema[i]\n        });\n      }\n\n      return {\n        add: add,\n        remove: remove\n      };\n    }\n  };\n  WGo.Position = Position;\n  /**\n   * Creates instance of game class.\n   *\n   * @class\n   * This class implements game logic. It basically analyses given moves and returns capture stones.\n   * WGo.Game also stores every position from beginning, so it has ability to check repeating positions\n   * and it can effectively restore old positions.</p>\n   *\n   * @param {number} size of the board\n   * @param {\"KO\"|\"ALL\"|\"NONE\"} checkRepeat (optional, default is \"KO\") - how to handle repeated position:\n   * KO - ko is properly handled - position cannot be same like previous position\n   * ALL - position cannot be same like any previous position - e.g. it forbids triple ko\n   * NONE - position can be repeated\n   *\n   * @param {boolean} allowRewrite (optional, default is false) - allow to play moves, which were already played:\n   * @param {boolean} allowSuicide (optional, default is false) - allow to play suicides, stones are immediately captured\n   */\n\n  var Game = function Game(size, checkRepeat, allowRewrite, allowSuicide) {\n    this.size = size || 19;\n    this.repeating = checkRepeat === undefined ? \"KO\" : checkRepeat; // possible values: KO, ALL or nothing\n\n    this.allow_rewrite = allowRewrite || false;\n    this.allow_suicide = allowSuicide || false;\n    this.stack = [];\n    this.stack[0] = new Position(this.size);\n    this.stack[0].capCount = {\n      black: 0,\n      white: 0\n    };\n    this.turn = WGo.B;\n    Object.defineProperty(this, \"position\", {\n      get: function get() {\n        return this.stack[this.stack.length - 1];\n      },\n      set: function set(pos) {\n        this.stack[this.stack.length - 1] = pos;\n      }\n    });\n  }; // function for stone capturing\n\n\n  var do_capture = function do_capture(position, captured, x, y, c) {\n    if (x >= 0 && x < position.size && y >= 0 && y < position.size && position.get(x, y) == c) {\n      position.set(x, y, 0);\n      captured.push({\n        x: x,\n        y: y\n      });\n      do_capture(position, captured, x, y - 1, c);\n      do_capture(position, captured, x, y + 1, c);\n      do_capture(position, captured, x - 1, y, c);\n      do_capture(position, captured, x + 1, y, c);\n    }\n  }; // looking at liberties\n\n\n  var check_liberties = function check_liberties(position, testing, x, y, c) {\n    // out of the board there aren't liberties\n    if (x < 0 || x >= position.size || y < 0 || y >= position.size) return true; // however empty field means liberty\n\n    if (position.get(x, y) == 0) return false; // already tested field or stone of enemy isn't giving us a liberty.\n\n    if (testing.get(x, y) == true || position.get(x, y) == -c) return true; // set this field as tested\n\n    testing.set(x, y, true); // in this case we are checking our stone, if we get 4 trues, it has no liberty\n\n    return check_liberties(position, testing, x, y - 1, c) && check_liberties(position, testing, x, y + 1, c) && check_liberties(position, testing, x - 1, y, c) && check_liberties(position, testing, x + 1, y, c);\n  }; // analysing function - modifies original position, if there are some capturing, and returns array of captured stones\n\n\n  var check_capturing = function check_capturing(position, x, y, c) {\n    var captured = []; // is there a stone possible to capture?\n\n    if (x >= 0 && x < position.size && y >= 0 && y < position.size && position.get(x, y) == c) {\n      // create testing map\n      var testing = new Position(position.size); // if it has zero liberties capture it\n\n      if (check_liberties(position, testing, x, y, c)) {\n        // capture stones from game\n        do_capture(position, captured, x, y, c);\n      }\n    }\n\n    return captured;\n  }; // analysing history\n\n\n  var checkHistory = function checkHistory(position, x, y) {\n    var flag, stop;\n    if (this.repeating == \"KO\" && this.stack.length - 2 >= 0) stop = this.stack.length - 2;else if (this.repeating == \"ALL\") stop = 0;else return true;\n\n    for (var i = this.stack.length - 2; i >= stop; i--) {\n      if (this.stack[i].get(x, y) == position.get(x, y)) {\n        flag = true;\n\n        for (var j = 0; j < this.size * this.size; j++) {\n          if (this.stack[i].schema[j] != position.schema[j]) {\n            flag = false;\n            break;\n          }\n        }\n\n        if (flag) return false;\n      }\n    }\n\n    return true;\n  };\n\n  Game.prototype = {\n    constructor: Game,\n\n    /**\n     * Gets actual position.\n     *\n     * @return {WGo.Position} actual position\n     */\n    getPosition: function getPosition() {\n      return this.stack[this.stack.length - 1];\n    },\n\n    /**\n     * Play move.\n     *\n     * @param {number} x coordinate\n     * @param {number} y coordinate\n     * @param {(WGo.B|WGo.W)} c color\n     * @param {boolean} noplay - if true, move isn't played. Used by WGo.Game.isValid.\n     * @return {number} code of error, if move isn't valid. If it is valid, function returns array of captured stones.\n     *\n     * Error codes:\n     * 1 - given coordinates are not on board\n     * 2 - on given coordinates already is a stone\n     * 3 - suicide (currently they are forbbiden)\n     * 4 - repeated position\n     */\n    play: function play(x, y, c, noplay) {\n      //check coordinates validity\n      if (!this.isOnBoard(x, y)) return 1;\n      if (!this.allow_rewrite && this.position.get(x, y) != 0) return 2; // clone position\n\n      if (!c) c = this.turn;\n      var new_pos = this.position.clone();\n      new_pos.set(x, y, c); // check capturing\n\n      var cap_color = c;\n      var captured = check_capturing(new_pos, x - 1, y, -c).concat(check_capturing(new_pos, x + 1, y, -c), check_capturing(new_pos, x, y - 1, -c), check_capturing(new_pos, x, y + 1, -c)); // check suicide\n\n      if (!captured.length) {\n        var testing = new Position(this.size);\n\n        if (check_liberties(new_pos, testing, x, y, c)) {\n          if (this.allow_suicide) {\n            cap_color = -c;\n            do_capture(new_pos, captured, x, y, c);\n          } else return 3;\n        }\n      } // check history\n\n\n      if (this.repeating && !checkHistory.call(this, new_pos, x, y)) {\n        return 4;\n      }\n\n      if (noplay) return false; // update position info\n\n      new_pos.color = c;\n      new_pos.capCount = {\n        black: this.position.capCount.black,\n        white: this.position.capCount.white\n      };\n      if (cap_color == WGo.B) new_pos.capCount.black += captured.length;else new_pos.capCount.white += captured.length; // save position\n\n      this.pushPosition(new_pos); // reverse turn\n\n      this.turn = -c;\n      return captured;\n    },\n\n    /**\n     * Play pass.\n     *\n     * @param {(WGo.B|WGo.W)} c color\n     */\n    pass: function pass(c) {\n      this.pushPosition();\n\n      if (c) {\n        this.position.color = c;\n        this.turn = -c;\n      } else {\n        this.position.color = this.turn;\n        this.turn = -this.turn;\n      }\n    },\n\n    /**\n     * Finds out validity of the move.\n     *\n     * @param {number} x coordinate\n     * @param {number} y coordinate\n     * @param {(WGo.B|WGo.W)} c color\n     * @return {boolean} true if move can be played.\n     */\n    isValid: function isValid(x, y, c) {\n      return typeof this.play(x, y, c, true) != \"number\";\n    },\n\n    /**\n     * Controls position of the move.\n     *\n     * @param {number} x coordinate\n     * @param {number} y coordinate\n     * @return {boolean} true if move is on board.\n     */\n    isOnBoard: function isOnBoard(x, y) {\n      return x >= 0 && y >= 0 && x < this.size && y < this.size;\n    },\n\n    /**\n     * Inserts move into current position. Use for setting position, for example in handicap game. Field must be empty.\n     *\n     * @param {number} x coordinate\n     * @param {number} y coordinate\n     * @param {(WGo.B|WGo.W)} c color\n     * @return {boolean} true if operation is successfull.\n     */\n    addStone: function addStone(x, y, c) {\n      if (this.isOnBoard(x, y) && this.position.get(x, y) == 0) {\n        this.position.set(x, y, c || 0);\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n     * Removes move from current position.\n     *\n     * @param {number} x coordinate\n     * @param {number} y coordinate\n     * @return {boolean} true if operation is successfull.\n     */\n    removeStone: function removeStone(x, y) {\n      if (this.isOnBoard(x, y) && this.position.get(x, y) != 0) {\n        this.position.set(x, y, 0);\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n     * Set or insert move of current position.\n     *\n     * @param {number} x coordinate\n     * @param {number} y coordinate\n     * @param {(WGo.B|WGo.W)} c color\n     * @return {boolean} true if operation is successfull.\n     */\n    setStone: function setStone(x, y, c) {\n      if (this.isOnBoard(x, y)) {\n        this.position.set(x, y, c || 0);\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n     * Get stone on given position.\n     *\n     * @param {number} x coordinate\n     * @param {number} y coordinate\n     * @return {(WGo.B|WGo.W|0)} color\n     */\n    getStone: function getStone(x, y) {\n      if (this.isOnBoard(x, y)) {\n        return this.position.get(x, y);\n      }\n\n      return 0;\n    },\n\n    /**\n     * Add position to stack. If position isn't specified current position is cloned and stacked.\n     * Pointer of actual position is moved to the new position.\n     *\n     * @param {WGo.Position} tmp position (optional)\n     */\n    pushPosition: function pushPosition(pos) {\n      if (!pos) {\n        var pos = this.position.clone();\n        pos.capCount = {\n          black: this.position.capCount.black,\n          white: this.position.capCount.white\n        };\n        pos.color = this.position.color;\n      }\n\n      this.stack.push(pos);\n      if (pos.color) this.turn = -pos.color;\n      return this;\n    },\n\n    /**\n     * Remove current position from stack. Pointer of actual position is moved to the previous position.\n     */\n    popPosition: function popPosition() {\n      var old = null;\n\n      if (this.stack.length > 0) {\n        old = this.stack.pop();\n        if (this.stack.length == 0) this.turn = WGo.B;else if (this.position.color) this.turn = -this.position.color;else this.turn = -this.turn;\n      }\n\n      return old;\n    },\n\n    /**\n     * Removes all positions.\n     */\n    firstPosition: function firstPosition() {\n      this.stack = [];\n      this.stack[0] = new Position(this.size);\n      this.stack[0].capCount = {\n        black: 0,\n        white: 0\n      };\n      this.turn = WGo.B;\n      return this;\n    },\n\n    /**\n     * Gets count of captured stones.\n     *\n     * @param {(WGo.BLACK|WGo.WHITE)} color\n     * @return {number} count\n     */\n    getCaptureCount: function getCaptureCount(color) {\n      return color == WGo.B ? this.position.capCount.black : this.position.capCount.white;\n    },\n\n    /**\n     * Validate postion. Position is tested from 0:0 to size:size, if there are some moves, that should be captured, they will be removed.\n     * You can use this, after insertion of more stones.\n     *\n     * @return array removed stones\n     */\n    validatePosition: function validatePosition() {\n      var c,\n          p,\n          white = 0,\n          black = 0,\n          captured = [],\n          new_pos = this.position.clone();\n\n      for (var x = 0; x < this.size; x++) {\n        for (var y = 0; y < this.size; y++) {\n          c = this.position.get(x, y);\n\n          if (c) {\n            p = captured.length;\n            captured = captured.concat(check_capturing(new_pos, x - 1, y, -c), check_capturing(new_pos, x + 1, y, -c), check_capturing(new_pos, x, y - 1, -c), check_capturing(new_pos, x, y + 1, -c));\n            if (c == WGo.B) black += captured - p;else white += captured - p;\n          }\n        }\n      }\n\n      this.position.capCount.black += black;\n      this.position.capCount.white += white;\n      this.position.schema = new_pos.schema;\n      return captured;\n    }\n  }; // save Game\n\n  WGo.Game = Game; // register WGo\n\n  window.WGo = WGo;\n})(window);\n\n//# sourceURL=webpack:///./view/assets/games/Go/wgo.js?");

/***/ })

}]);